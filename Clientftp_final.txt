/* 
 * Client FTP program
 * 
 *
 *  - Connect to the FTP server on SERVER_FTP_PORT over the control connection.
 *  - Read one command per line from the keyboard and send the EXACT line to the server.
 *  - Receive and display the server's reply message(s) for each command.
 *  - Exit cleanly when the user types "quit".
 *
 * Commands you must be able to SEND (the server implements/validates them):
 *   user <username>, pass <password>, quit,
 *   mkdir|mkd <dir>, rmdir|rmd <dir>, cd|cwd <dir>,
 *   dele <filename>, pwd, ls, stat|status, help
 * Control: client -> server on SERVER_FTP_PORT
 * Data:    server -> client on DATA_FTP_PORT (reverse of control)
 *
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>
#include <stdio.h>   
#include <unistd.h>  
#include <stdlib.h>
#include <errno.h>

#define SERVER_FTP_PORT 9119
#define DATA_FTP_PORT 9120

/* Error and OK codes */
#define OK 0
#define ER_INVALID_HOST_NAME -1
#define ER_CREATE_SOCKET_FAILED -2
#define ER_BIND_FAILED -3
#define ER_CONNECT_FAILED -4
#define ER_SEND_FAILED -5
#define ER_RECEIVE_FAILED -6


/* Function prototypes */

int clntConnect(char *serverName, int *s);
int sendMessage (int s, char *msg, int  msgSize);
int receiveMessage(int s, char *buffer, int  bufferSize, int *msgSize);
int svcInitServer(int *s); 

/* List of all global variables */

static char userCmd[1024];	/* user typed ftp command line read from keyboard */
static char cmd[1024];		/* ftp command extracted from userCmd */
static char argument[1024];	/* argument extracted from userCmd */
static char replyMsg[1024];    /* buffer to receive reply message from server */


/**
 * parse_cmd
 * Splits a raw input line into:
 *   - out_cmd : the first whitespace-delimited token (command)
 *   - out_arg : the remainder of the line (trimmed of leading spaces and trailing CR/LF)
 *
 * Behavior:
 *   - Ignores leading spaces/tabs in the input.
 *   - Treats any sequence of spaces/tabs/newline as a delimiter after the command token.
 *   - Copies safely into caller-provided buffers (csz/asz cap), always NUL-terminates.
 *   - If no command token is found, both outputs are set to empty strings.
 *
 * Params:
 *  - line     : (in)  input line (may contain trailing '\n'/'\r'); may be NULL
 *  - out_cmd  : (out) destination buffer for the command token
 *  - csz      : (in)  size of out_cmd in bytes
 *  - out_arg  : (out) destination buffer for the remaining argument text
 *  - asz      : (in)  size of out_arg in bytes
 *
 * Returns:
 *  - void (results are written into out_cmd / out_arg)
 */
static void parse_cmd(const char *line, char *out_cmd, size_t csz, char *out_arg, size_t asz) {
    out_cmd[0] = out_arg[0] = '\0';
    if (!line) return;
    /* copy original to a temp we can strtok */
    char tmp[1024];
    strncpy(tmp, line, sizeof(tmp)-1);
    tmp[sizeof(tmp)-1] = '\0';

    char *tok = strtok(tmp, " \t\r\n");
    if (tok) {
        strncpy(out_cmd, tok, csz-1); out_cmd[csz-1] = '\0';
        char *rest = strtok(NULL, "");
        if (rest) {
            /* trim leading spaces from rest */
            while (*rest==' '||*rest=='\t') rest++;
            strncpy(out_arg, rest, asz-1); out_arg[asz-1] = '\0';
        }
    }
}


/*
 * main
 * Function connects to the ftp server using clntConnect function.
 * Reads one ftp command in one line from the keyboard into userCmd array.
 * Sends the user command to the server.
 * Receive reply message from the server.
 * On receiving reply to QUIT ftp command from the server,
 * close the control connection socket and exit from main
 *
 * Parameters
 * argc		- Count of number of arguments passed to main (input)
 * argv  	- Array of pointer to input parameters to main (input)
 *		   It is not required to pass any parameter to main
 *		   Can use it if needed.
 *
 * Return status
 *	OK	- Successful execution until QUIT command from client 
 *	N	- Failed status, value of N depends on the function called or cmd processed
 */

int main(int argc, char *argv[])
{
    int ccSocket;
    int msgSize;
    int status = OK;
    char rawInput[1024];
    int dcListenSocket = -1;

    printf("Started execution of client ftp\n");

    printf("Calling clntConnect to connect to the server\n");
    status = clntConnect("127.0.0.1", &ccSocket);
    if (status != OK) {
        printf("Connection to server failed, exiting main.\n");
        return status;
    }

    /* Prepare active-mode data listener */
    status = svcInitServer(&dcListenSocket);
    if (status != OK) {
        printf("Data listener setup failed. Exiting.\n");
        close(ccSocket);
        return status;
    }

    /* Read the server's initial greeting (e.g., "220 ...") */
    status = receiveMessage(ccSocket, replyMsg, sizeof(replyMsg), &msgSize);
    if (status != OK || msgSize <= 0) {
        printf("Failed to read server greeting.\n");
	close(dcListenSocket);
        close(ccSocket);
        return ER_RECEIVE_FAILED;
    }

    do {
        printf("my ftp> ");
        fflush(stdout); /* Ensure prompt is shown */

        if (fgets(userCmd, sizeof(userCmd), stdin) == NULL) {
            break; /* EOF or error */
        }
        userCmd[strcspn(userCmd, "\n")] = '\0';

        strncpy(rawInput, userCmd, sizeof(rawInput)-1);
        rawInput[sizeof(rawInput)-1] = '\0';

        /* Parse cmd for local logic */
        parse_cmd(userCmd, cmd, sizeof(cmd), argument, sizeof(argument));
        if (cmd[0] == '\0') continue;

        /* Send request */
        status = sendMessage(ccSocket, rawInput, (int)strlen(rawInput)+1);
        if (status != OK) break;
	
	/* For put/get expected two replies (150 then 226).
           For other commands a single reply. */
        int is_put = (strcmp(cmd, "put") == 0);
        int is_get = (strcmp(cmd, "get") == 0);

        if (is_put || is_get) {
            /* Expect a preliminary reply from the server for transfers:
             * typically "150 ..." (File status okay; about to open data connection),
             * or an error 5xx if something went wrong before data phase. */
            status = receiveMessage(ccSocket, replyMsg, sizeof(replyMsg), &msgSize);
            if (status != OK || msgSize <= 0) break;

            /* If first reply is an error (>= 400), skip data stage */
            int code = 0; sscanf(replyMsg, "%d", &code);
            if (code >= 400) {
                /* one error reply only */
                continue;
            }

            /* Active mode (reverse of control): the client is listening on dcListenSocket,
             * and the server connects back to it for this single transfer. Accept that one
             * incoming data connection from the server. */
            int dcSocket = accept(dcListenSocket, NULL, NULL);
            if (dcSocket < 0) {
                perror("accept (data)");
                /* Even if data accept failed, the server will still send a final control reply
                 * (e.g., 425). Read it so the control channel stays in sync. */
                status = receiveMessage(ccSocket, replyMsg, sizeof(replyMsg), &msgSize);
                if (status != OK || msgSize <= 0) break;
                continue;
            }

            if (is_put) {
		/* PUT: upload local file -> server */
                if (argument[0] == '\0') {
		     /* No local filename provided; nothing to send on data socket. */
                    printf("Local filename required for put.\n");
                    close(dcSocket);
                } else {
		    /* Open the local file for reading */
                    FILE *f = fopen(argument, "rb");
                    if (!f) {
                        perror("fopen (put)");
                        /* close data; let server see EOF quickly */
                        close(dcSocket);
                    } else {
                        char buf[4096];
                        size_t n;
			/* Read chunks from the local file and send over the data socket. */
                        while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
                            ssize_t sent = send(dcSocket, buf, (int)n, 0);
                            if (sent < 0) { perror("send (put)"); break; }
                        }
                        fclose(f);
                        shutdown(dcSocket, SHUT_WR);
                        close(dcSocket);
                    }
                }
            } else if (is_get) {
		 /* GET: download server file -> local */
                if (argument[0] == '\0') {
		    /* If no name was provided, still drain the socket so control stays synced. */
                    printf("Local filename required for get (this client saves to the same name you typed).\n");
                }
                /* Save into 'argument' (or "downloaded_file" if empty) */
                const char *outname = (argument[0]? argument : "downloaded_file");
                FILE *f = fopen(outname, "wb");
                if (!f) {
                    perror("fopen (get)");
                    /* drain to /dev/null style */
                    char buf[4096];
                    ssize_t r;
                    while ((r = recv(dcSocket, buf, sizeof(buf), 0)) > 0) { /* discard */ }
                    close(dcSocket);
                } else {
                    char buf[4096];
                    ssize_t r;
                    while ((r = recv(dcSocket, buf, sizeof(buf), 0)) > 0) {
                        size_t w = fwrite(buf, 1, (size_t)r, f);
                        if (w < (size_t)r) { perror("fwrite (get)"); break; }
                    }
                    fclose(f);
                    close(dcSocket);
                }
            }
	    /* Final reply (226 or an error) */
            status = receiveMessage(ccSocket, replyMsg, sizeof(replyMsg), &msgSize);
            if (status != OK || msgSize <= 0) break;
	} else {
            /* Single-reply command */
            status = receiveMessage(ccSocket, replyMsg, sizeof(replyMsg), &msgSize);
            if (status != OK || msgSize <= 0) break;
	}
  
    } while (strcmp(cmd, "quit") != 0);

    printf("Closing control connection \n");
    if (dcListenSocket >= 0) close(dcListenSocket);
    close(ccSocket);
    printf("Exiting client main \n");
    return status;
}  /* end main() */


/*
 * clntConnect
 *
 * Function to create a socket, bind local client IP address and port to the socket
 * and connect to the server
 *
 * Parameters
 * serverName	- IP address of server in dot notation (input)
 * s		- Control connection socket number (output)
 *
 * Return status
 *	OK			- Successfully connected to the server
 *	ER_INVALID_HOST_NAME	- Invalid server name
 *	ER_CREATE_SOCKET_FAILED	- Cannot create socket
 *	ER_BIND_FAILED		- bind failed
 *	ER_CONNECT_FAILED	- connect failed
 */


int clntConnect (
	char *serverName, /* server IP address in dot notation (input) */
	int *s 		  /* control connection socket number (output) */
	)
{
	int sock;	/* local variable to keep socket number */

	struct sockaddr_in clientAddress;  	/* local client IP address */
	struct sockaddr_in serverAddress;	/* server IP address */
	struct hostent	   *serverIPstructure;	/* host entry having server IP address in binary */


	/* Get IP address os server in binary from server name (IP in dot natation) */
	if((serverIPstructure = gethostbyname(serverName)) == NULL)
	{
		printf("%s is unknown server. \n", serverName);
		return (ER_INVALID_HOST_NAME);  /* error return */
	}

	/* Create control connection socket */
	if((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		perror("cannot create socket ");
		return (ER_CREATE_SOCKET_FAILED);	/* error return */
	}

	/* initialize client address structure memory to zero */
	memset((char *) &clientAddress, 0, sizeof(clientAddress));

	/* Set local client IP address, and port in the address structure */
	clientAddress.sin_family = AF_INET;	/* Internet protocol family */
	clientAddress.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY is 0, which means */
						 /* let the system fill client IP address */
	clientAddress.sin_port = 0;  /* With port set to 0, system will allocate a free port */
			  /* from 1024 to (64K -1) */

	/* Associate the socket with local client IP address and port */
	if(bind(sock,(struct sockaddr *)&clientAddress,sizeof(clientAddress))<0)
	{
		perror("cannot bind");
		close(sock);
		return(ER_BIND_FAILED);	/* bind failed */
	}


	/* Initialize serverAddress memory to 0 */
	memset((char *) &serverAddress, 0, sizeof(serverAddress));

	/* Set ftp server ftp address in serverAddress */
	serverAddress.sin_family = AF_INET;
	memcpy((char *) &serverAddress.sin_addr, serverIPstructure->h_addr, 
			serverIPstructure->h_length);
	serverAddress.sin_port = htons(SERVER_FTP_PORT);

	/* Connect to the server */
	if (connect(sock, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)
	{
		perror("Cannot connect to server ");
		close (sock); 	/* close the control connection socket */
		return(ER_CONNECT_FAILED);  	/* error return */
	}


	/* Store listen socket number to be returned in output parameter 's' */
	*s=sock;

	return(OK); /* successful return */
}  

/*
 * sendMessage
 *
 * Function to send specified number of octet (bytes) to client ftp
 *
 * Parameters
 * s		- Socket to be used to send msg to client (input)
 * msg  	- Pointer to character arrary containing msg to be sent (input)
 * msgSize	- Number of bytes, including NULL, in the msg to be sent to client (input)
 *
 * Return status
 *	OK		- Msg successfully sent
 *	ER_SEND_FAILED	- Sending msg failed
 */

int sendMessage(
	int s, 		/* socket to be used to send msg to client */
	char *msg, 	/*buffer having the message data */
	int msgSize 	/*size of the message/data in bytes */
	)
{
	int i;


	/* Print the message to be sent byte by byte as character */
	for(i=0;i<msgSize;i++)
	{
		printf("%c",msg[i]);
	}
	printf("\n");

	if((send(s,msg,msgSize,0)) < 0) /* socket interface call to transmit */
	{
		perror("unable to send ");
		return(ER_SEND_FAILED);
	}

	return(OK); /* successful send */
}


/*
 * receiveMessage
 *
 * Function to receive message from client ftp
 *
 * Parameters
 * s		- Socket to be used to receive msg from client (input)
 * buffer  	- Pointer to character arrary to store received msg (input/output)
 * bufferSize	- Maximum size of the array, "buffer" in octent/byte (input)
 *		    This is the maximum number of bytes that will be stored in buffer
 * msgSize	- Actual # of bytes received and stored in buffer in octet/byes (output)
 *
 * Return status
 *	OK			- Msg successfully received
 *	ER_RECEIVE_FAILED	- Receiving msg failed
 */

int receiveMessage (
	int s, 		/* socket */
	char *buffer, 	/* buffer to store received msg */
	int bufferSize, /* how large the buffer is in octet */
	int *msgSize 	/* size of the received msg in octet */
	)
{
	int i;

	*msgSize=recv(s,buffer,bufferSize,0); /* socket interface call to receive msg */

	if(*msgSize<0)
	{
		perror("unable to receive");
		return(ER_RECEIVE_FAILED);
	}

	/* Print the received msg byte by byte */
	for(i=0;i<*msgSize;i++)
	{
		printf("%c", buffer[i]);
	}
	printf("\n");

	return (OK);
}


/*
 * clntExtractReplyCode
 * Function to extract the three digit reply code 
 * from the server reply message received.
 * It is assumed that the reply message string is of the following format
 *      ddd  text
 * where ddd is the three digit reply code followed by or or more space.
 *
 * Parameters
 *	buffer	  - Pointer to an array containing the reply message (input)
 *	replyCode - reply code number (output)
 *
 * Return status
 *	OK	- Successful (returns always success code
 */

int clntExtractReplyCode (
	char	*buffer,    /* Pointer to an array containing the reply message (input) */
	int	*replyCode  /* reply code (output) */
	)
{
	/* extract the codefrom the server reply message */
   sscanf(buffer, "%d", replyCode);

   return (OK);
}  // end of clntExtractReplyCode()

int svcInitServer (int *s) {
    int sock;
    struct sockaddr_in svcAddr;
    int qlen = 1;

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("cannot create socket");
        return ER_CREATE_SOCKET_FAILED;
    }
    memset((char *)&svcAddr, 0, sizeof(svcAddr));
    svcAddr.sin_family = AF_INET;
    svcAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    svcAddr.sin_port = htons(DATA_FTP_PORT);
    if (bind(sock, (struct sockaddr *)&svcAddr, sizeof(svcAddr)) < 0) {
        perror("cannot bind");
        close(sock);
        return ER_BIND_FAILED;
    }
    if (listen(sock, qlen) < 0) {
        perror("listen");
        close(sock);
        return ER_BIND_FAILED;
    }
    *s = sock;
    return OK;
}
